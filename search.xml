<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[无线WLAN隧道转发模式下数据的封装以及转发过程]]></title>
    <url>%2F2019%2F06%2F22%2F%E6%97%A0%E7%BA%BFWLAN%E9%9A%A7%E9%81%93%E8%BD%AC%E5%8F%91%E6%A8%A1%E5%BC%8F%E4%B8%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E5%B0%81%E8%A3%85%E4%BB%A5%E5%8F%8A%E8%BD%AC%E5%8F%91%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[无线WLAN隧道转发模式下数据的封装以及转发过程实验用的拓扑： AP1、AP2的业务vlan为101、102，管理vlan为100，AR路由器作为DHCP服务器为AP和终端分配IP地址、DNS等信息。 vlan100、101、102的网关都在核心交换机上。 核心交换机上做DHCP中继，把AP与终端的dhcp请求转到服务器上。 分别使用直接转发模式和隧道转发模式。 遇到的问题 在进行完正常的配置，AP上线、下发配置后，直接转发模式下的终端连接AP结果正常，但是在改为隧道转发模式后终端却怎么也获取不到IP信息，一直处于正在连接的状态。 当时感到困惑的是，通过wireshark抓包分析发现，这个请求包在并没有按照预想的通过中继来到dhcp服务器这里，进一步分析发现终端的dhcp discover封装了两层的vlan tag，内层为AP的业务vlan，外层为管理vlan，这时才恍然大悟，隧道模式下，数据会通过隧道封装先送到AC在进行处理。而业务vlan在核心交换机也就是网关那里就终结了，AC上并没有这些vlan信息，也不能为终端提供dhcp服务，导致了终端一直处于连接的状态。 这个时候解决问题的思路也就清晰了。 把AC配成dhcp服务器，直接为终端提供服务 在AC上添加业务vlan的信息，把dhcp请求中继到AR路由器上，依旧由AR提供dhcp服务。 通过上述方法配置后，一切就正常了。下面附上华为官方关于两种转发模式的介绍。 业务数据报文直接转发的处理流程如下图所示，直接转发模式下，业务数据报文不经过CAPWAP封装。 上行（STA–&gt;Internet）：AP收到STA的802.11格式的上行业务数据，由AP直接转换为802.3报文并标记业务VLAN s后向目的地发送。 下行（Internet–&gt;STA）：下行业务数据以802.3报文到达AP（由上层网络设备标记业务VLAN s’），由AP转换为802.11格式发送给STA。 中间网络设备需配置和透传业务VLAN s，这种组网模式下，AC一般旁挂在核心交换机或汇聚交换机上，不承担数据业务转发功能，只对AP进行管理。如果AC处于直连位置时，数据报文也需要通过AC进行转发，此时AC可视为承担汇聚交换机功能。 业务数据报文CAPWAP隧道转发的处理流程如下图所示，AP与AC之间同时建立控制隧道和数据隧道，WLAN用户业务数据和管理报文分别封装在CAPWAP数据报文和CAPWAP控制报文中，在CAPWAP隧道中传递。 上行（STA–&gt;Internet）：AP收到STA的802.11格式的上行业务数据，由AP直接转换为802.3报文并标记业务VLAN s，然后AP封装上行业务数据到CAPWAP报文中；由连接AP的交换机标记管理VLAN m；AC接收后解CAPWAP封装并终结VLAN m’。 下行（Internet–&gt;STA）：下行业务数据由AC封装到CAPWAP报文中，AC允许携带VLAN s的报文通过并对该报文标记VLAN m’，由AC标记业务VLAN s和管理VLAN m’；由连接AP的交换机终结VLAN m；由AP接收后解CAPWAP封装并终结VLAN s，并将802.3报文转换为802.11报文发送给STA。 封装后的报文在CAPWAP报文外层使用管理VLAN m，AP与AC之间的网络设备只能透传管理VLAN m，而对封装在CAPWAP报文内的业务VLAN s不能放通。 AC处于直连和旁挂位置时，封装后的数据包都需要由AC处理和转发。]]></content>
      <categories>
        <category>华为</category>
      </categories>
      <tags>
        <tag>wlan</tag>
        <tag>华为</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[socket实现FTP客户端]]></title>
    <url>%2F2019%2F04%2F18%2F%E9%80%9A%E8%BF%87socket%E5%AE%9E%E7%8E%B0FTP%E5%AE%A2%E6%88%B7%E7%AB%AF%EF%BC%88MFC%E7%89%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[通过socket实现FTP客户端（MFC版）使用socket我们可以自己编写一个FTP的客户端。开始之前先了解FTP的两种工作模式大致的过程。 被动模式的流程被动模式下，FTP客户端使用一个非知名的随机端口N（&gt;1024)去连接FTP服务器的21端口建立控制连接，然后通过控制通道发送PASV命令到服务器，服务器收到后会开启一个随机端口P（&gt;1024）并开始监听，同时告诉客户端连接我的端口P，客户端随后使用N+1端口连接服务器的端口P，建立数据连接。 主动模式的流程主动模式下，FTP客户端使用一个非知名的随机端口N（&gt;1024)去连接FTP服务器的21端口建立控制连接，然后通过控制通道发送PORT N+1命令到服务器，同时开始监听N+1端口，服务器收到后主动使用20端口与客户端的N+1端口连接，建立数据连接。 客户端与服务器交互的常用命令这里的命令是指底层数据包封装的命令，并不是指用户在控制台使用的与服务器交互的命令，比如dir、get、put等等。 客户端使用 USER、PASS 命令登录 FTP 服务器。 客户端使用 PASV 命令告知服务器使用被动模式，获取服务器数据连接的端口号，与服务器建立数据连接。 客户端使用PORT命令告知服务器使用主动模式，附带自己监听的数据端口，让服务器主动与其建立数据连接。 客户端使用SIZE命令获取文件的大小。 客户端使用 RETR、STOR 命令下载、上传文件。 客户端使用 QUIT 命令退出连接。 使用socket实现FTP客户端创建socket 12345678910111213WSADATA WSAData; if (WSAStartup(MAKEWORD(2,2),&amp;WSAData)!=0)//建立套接字绑定 &#123; MessageBox("初始化Winsock失败！"); return; &#125; SockCtrl=socket(AF_INET,SOCK_STREAM,0);//创建连接套接字 if (SockCtrl==INVALID_SOCKET) &#123; MessageBox("创建控制Socket失败！"); WSACleanup(); return; &#125; 建立控制连接 12345678910111213141516171819202122232425nConnect=connect(SockCtrl,(sockaddr*)&amp;serveraddr,sizeof(serveraddr));//建立FTP控制连接 if (nConnect==SOCKET_ERROR) &#123; MessageBox("控制连接建立失败！"); closesocket(SockCtrl); WSACleanup(); return; &#125; if (!RecvRespond()) return; else &#123;//判断连接应答码 if (RespondCode==220) &#123; m_tips+="Server: "; m_tips+=Respond; &#125; else &#123; MessageBox("控制连接响应错误！"); closesocket(SockCtrl); WSACleanup(); return; &#125; &#125; 定义SendCommand函数，用于客户端发送命令 123456789101112131415//发送命令bool CFtpClientDlg::SendCommand(void)&#123; int nSend; nSend=send(SockCtrl,Command,strlen(Command),0); if (nSend==SOCKET_ERROR) &#123; MessageBox("Socket发送失败！"); closesocket(SockCtrl); WSACleanup(); return false; &#125; return true;&#125; 定义RecvRespond函数，用于客户端接收响应码 1234567891011121314151617181920//接收响应码bool CFtpClientDlg::RecvRespond(void)&#123; int nRecv; memset(Respond,0,MAX_SIZE); nRecv=recv(SockCtrl,Respond,MAX_SIZE,0);//通过连接接收响应 if (nRecv==SOCKET_ERROR) &#123; MessageBox("Socket接收失败！"); closesocket(SockCtrl); WSACleanup(); return false; &#125; //从响应中解析响应码 char* ReplyCodes=new char[3]; memset(ReplyCodes,0,3); memcpy(ReplyCodes,Respond,3); RespondCode=atoi(ReplyCodes); return true;&#125; 验证用户名、口令 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152sprintf(Command,"USER %s\r\n",m_user); //Command为事先定义的缓冲区 if (!SendCommand()) return; m_tips+="Client: ";//m_tips为编辑框控件变量，用于显示交互过程 m_tips+=Command; if (!RecvRespond()) return; else &#123;//判断USER应答码 if (RespondCode==220 || RespondCode==331) &#123; m_tips+="Server: "; m_tips+=Respond; &#125; else &#123; MessageBox("USER响应错误！"); closesocket(SockCtrl); WSACleanup(); return; &#125; &#125; if (RespondCode==331)//User name okay,need password &#123; //合成PASS命令 memset(Command,0,MAX_SIZE); sprintf(Command,"PASS %s\r\n",m_pwd); if (!SendCommand()) return; m_tips+="Client: PASS ******\r\n"; if (!RecvRespond()) return; else &#123;//判断PASS响应码 if (RespondCode==230) &#123; m_tips+="Server: "; m_tips+=Respond; m_CONNECT.EnableWindow(FALSE); m_QUIT.EnableWindow(TRUE); m_LIST.EnableWindow(TRUE); &#125; else &#123; MessageBox("PASS响应错误！"); closesocket(SockCtrl); WSACleanup(); return; &#125; &#125; 被动模式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970bool CFtpClientDlg::Pasv()&#123; UpdateData(TRUE); memset(Command,0,MAX_SIZE); //合成PASV命令 sprintf(Command,"PASV \r\n"); if (!SendCommand()) return false; m_tips+="Client: "; m_tips+=Command; if (!RecvRespond()) return false; else &#123; //判断PASV响应码 if (RespondCode!=227) &#123; MessageBox("PASV响应错误！"); closesocket(SockCtrl); WSACleanup(); return false; &#125; m_tips+="Server: "; m_tips+=Respond; &#125; char* part[6]; //分离PASV应答信息if (strtok(Respond,"(")) &#123; for (int i=0;i&lt;5;i++) &#123; part[i]=strtok(NULL,","); if (!part[i]) return false; &#125; part[5]=strtok(NULL,")"); if (!part[5]) return false; &#125; else return false; unsigned short ServerPort; //获取服务器数据端口 ServerPort=unsigned short((atoi(part[4])&lt;&lt;8)+atoi(part[5])); SockDataTongxin=socket(AF_INET,SOCK_STREAM,0); if (SockDataTongxin==INVALID_SOCKET) &#123; MessageBox("创建数据Socket失败！"); closesocket(SockCtrl); WSACleanup(); return false; &#125; sockaddr_in serveraddr2; serveraddr2.sin_family=AF_INET; serveraddr2.sin_addr.S_un.S_addr=inet_addr(m_addr); serveraddr2.sin_port=htons(ServerPort); int nConnect=connect(SockDataTongxin,(sockaddr*)&amp;serveraddr2,sizeof(serveraddr2)); if (nConnect==SOCKET_ERROR) &#123; MessageBox("数据连接失败！"); closesocket(SockCtrl); closesocket(SockDataTongxin); WSACleanup(); return false; &#125; UpdateData(FALSE); return true;&#125; 主动模式 注意：客户端指明要使用主动模式时，只有在有上传、下载请求发生时服务器才会主动与客户端建立数据连接（被动模式可以是客户端事先与服务器建立数据连接后再有上传下载的请求），所以主动模式下客户端的端口监听事件应该在发生了数据传输的请求之后。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283bool CFtpClientDlg::Port()&#123; UpdateData(TRUE); dataport+=1;//主动模式下，每建立一次数据连接，端口号都是在之前基础上+1 SockData=socket(AF_INET,SOCK_STREAM,0); if (SockData==INVALID_SOCKET) &#123; MessageBox("创建数据Socket失败！"); closesocket(SockCtrl); WSACleanup(); return false; &#125; sockaddr_in localaddr; int len=sizeof(localaddr); int ret = getsockname(SockCtrl,(sockaddr*)&amp;localaddr,&amp;len);//获取SockCtrl地址信息 if(ret!=0) &#123; printf("getsockname失败！"); return false; &#125; localport=ntohs(localaddr.sin_port)+dataport;//获取本地随机端口+1 localaddr.sin_family=AF_INET; localaddr.sin_port=htons(localport); //localaddr.sin_addr.S_un.S_addr=htonl(INADDR_ANY); ret =bind(SockData,(sockaddr*)&amp;localaddr,len); if (ret==SOCKET_ERROR) &#123; MessageBox("bind失败！"); closesocket(SockCtrl); closesocket(SockData); WSACleanup(); return false; &#125; ret =listen(SockData,64); if (ret==SOCKET_ERROR) &#123; MessageBox("listen失败！"); closesocket(SockCtrl); closesocket(SockData); WSACleanup(); return false; &#125; //inet_ntoa(localaddr.sin_addr); memset(Command,0,MAX_SIZE); //合成PORT命令 //itoa(localaddr.sin_addr,buf,10); char* part[6]; char buf1[5]; char buf2[5]; part[0]=strtok(inet_ntoa(localaddr.sin_addr),"."); part[1]=strtok(NULL,"."); part[2]=strtok(NULL,"."); part[3]=strtok(NULL,"."); part[4]=itoa(localport/256,buf1,10); part[5]=itoa(localport%256,buf2,10); sprintf(Command,"PORT %s,%s,%s,%s,%s,%s\r\n",part[0],part[1],part[2],part[3],part[4],part[5]); if (!SendCommand()) return false; m_tips+="Client: ";; m_tips+=Command; if (!RecvRespond()) return false; else &#123; //判断PORT响应码 if (RespondCode==200) &#123; m_tips+="Server: "; m_tips+=Respond; UpdateData(FALSE); return true; &#125;else &#123; MessageBox("PORT响应错误！"); closesocket(SockCtrl); WSACleanup(); return false; &#125; &#125; UpdateData(FALSE); return true;&#125; 被动模式下载文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647if(!Pasv()) return; UpdateData(TRUE); memset(Command,0,MAX_SIZE); sprintf(Command,"SIZE %s\r\n",m_filename); if (!SendCommand()) return; m_tips+="Client: "; m_tips+=Command; if (!RecvRespond())//接收响应 return; else &#123; m_tips+="Server: "; m_tips+=Respond; strtok(Respond," "); char *str; str=strtok(NULL,"\r\n"); size=atoi(str);//获取文件长度 if (RespondCode!=213) &#123; UpdateData(FALSE); m_TIPSCTRL.LineScroll(m_TIPSCTRL.GetLineCount());//滚动条置底 closesocket(SockDataTongxin); return; &#125; &#125; memset(Command,0,MAX_SIZE); sprintf(Command,"RETR %s\r\n",m_filename); if (!SendCommand()) return; m_tips+="Client: "; m_tips+=Command; if (!RecvRespond())//接收响应 return; else &#123; m_tips+="Server: "; m_tips+=Respond; if (RespondCode!=150) &#123; UpdateData(FALSE); m_TIPSCTRL.LineScroll(m_TIPSCTRL.GetLineCount());//滚动条置底 closesocket(SockDataTongxin); return; &#125; &#125; 主动模式下载文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859dataport+=1;//主动模式下，每建立一次数据连接，端口号都是在之前基础上+1if(!Port())return;UpdateData(TRUE); memset(Command,0,MAX_SIZE);sprintf(Command,"SIZE %s\r\n",m_filename);if (!SendCommand()) return;m_tips+="Client: ";m_tips+=Command;if (!RecvRespond())//接收响应 return;else&#123; m_tips+="Server: "; m_tips+=Respond; if (RespondCode!=213) &#123; UpdateData(FALSE); m_TIPSCTRL.LineScroll(m_TIPSCTRL.GetLineCount());//滚动条置底 closesocket(SockDataTongxin); return; &#125; &#125;strtok(Respond," ");char *str;str=strtok(NULL,"\r\n");size=atoi(str);//获取文件长度memset(Command,0,MAX_SIZE);sprintf(Command,"RETR %s\r\n",m_filename);if (!SendCommand()) return;m_tips+="Client: ";m_tips+=Command; //accept()在数据传输请求之后SockDataTongxin = accept(SockData,NULL,NULL);if (SockDataTongxin==INVALID_SOCKET)&#123; MessageBox("accept失败！"); //closesocket(SockCtrl); closesocket(SockData); return ;&#125;if (!RecvRespond())//接收响应 return;else&#123; m_tips+="Server: "; m_tips+=Respond; if (RespondCode!=150) &#123; UpdateData(FALSE); m_TIPSCTRL.LineScroll(m_TIPSCTRL.GetLineCount());//滚动条置底 closesocket(SockDataTongxin); return; &#125;&#125; 被动模式上传文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253if(!Pasv()) return; memset(Command,0,MAX_SIZE); sprintf(Command,"STOR %s\r\n",uploadfile);//uploadfile为事先定义的文件路径名变量 if (!SendCommand()) return; m_tips+="Client: "; m_tips+=Command; if (!RecvRespond())//接收响应 return; else &#123; m_tips+="Server: "; m_tips+=Respond; if (RespondCode!=150) &#123; //MessageBox("STOR响应错误！"); UpdateData(FALSE); m_TIPSCTRL.LineScroll(m_TIPSCTRL.GetLineCount());//滚动条置底 closesocket(SockDataTongxin); return; &#125; &#125; UpdateData(FALSE); FILE *fp=fopen(m_path,"rb"); fseek(fp,0,SEEK_SET); fseek(fp,0,SEEK_END); long length = ftell(fp);//获取文件长度 fseek(fp,0,SEEK_SET);//文件指针指回文件头 //char *Buf=new char(length);; char *Buf=new char[length]; fread(Buf,length,1,fp); fclose(fp); int ret=send(SockDataTongxin,Buf,length,0); if(ret==SOCKET_ERROR) &#123; MessageBox("上传文件失败！"); &#125; closesocket(SockDataTongxin); if (!RecvRespond())//接收响应 return; else &#123; m_tips+="Server: "; m_tips+=Respond; if (RespondCode!=226) &#123; UpdateData(FALSE); m_TIPSCTRL.LineScroll(m_TIPSCTRL.GetLineCount());//滚动条置底 closesocket(SockDataTongxin); return; &#125; &#125; 主动模式上传文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960dataport+=1;//主动模式下，每建立一次数据连接，端口号都是在之前基础上+1if(!Port())return;memset(Command,0,MAX_SIZE);sprintf(Command,"STOR %s\r\n",uploadfile);if (!SendCommand()) return;m_tips+="Client: ";m_tips+=Command;//accept()在数据传输请求之后SockDataTongxin = accept(SockData,NULL,NULL);if (SockDataTongxin==INVALID_SOCKET)&#123; MessageBox("accept失败！"); closesocket(SockData); return ;&#125;if (!RecvRespond())//接收响应 return;else&#123; m_tips+="Server: "; m_tips+=Respond; if (RespondCode!=150) &#123; //MessageBox("STOR响应错误！"); UpdateData(FALSE); m_TIPSCTRL.LineScroll(m_TIPSCTRL.GetLineCount());//滚动条置底 closesocket(SockDataTongxin); return; &#125; &#125; FILE *fp1=fopen(m_path,"rb");fseek(fp1,0,SEEK_SET);fseek(fp1,0,SEEK_END); long length = ftell(fp1);//获取文件长度fseek(fp1,0,SEEK_SET);//文件指针指回文件头char *Buf=new char[length];fread(Buf,length,1,fp1);fclose(fp1);int ret=send(SockDataTongxin,Buf,length,0);if(ret==SOCKET_ERROR)&#123; MessageBox("上传文件失败！");&#125;closesocket(SockDataTongxin);if (!RecvRespond())//接收响应 return;else&#123; m_tips+="Server: "; m_tips+=Respond; if (RespondCode!=150) &#123; UpdateData(FALSE); m_TIPSCTRL.LineScroll(m_TIPSCTRL.GetLineCount());//滚动条置底 closesocket(SockDataTongxin); return; &#125; &#125; 与服务器断开连接 这里断开的是控制连接，数据连接则是每一次数据传输时建立，传输结束时就断开的。 12345678910111213141516171819202122232425262728293031323334353637svoid CFtpClientDlg::OnBnClickedQuit()&#123; // TODO: 在此添加控件通知处理程序代码 memset(Command,0,MAX_SIZE); //合成QUIT命令 sprintf(Command,"QUIT\r\n"); if (!SendCommand()) return; m_tips+="Client: "; m_tips+=Command; if (!RecvRespond()) return; else &#123; if (RespondCode==221) &#123; m_tips+="Server: "; m_tips+=Respond; m_direc=""; m_CONNECT.EnableWindow(TRUE); m_QUIT.EnableWindow(FALSE); m_LIST.EnableWindow(FALSE); &#125; else &#123; m_tips+="Server: "; m_tips+=Respond; m_direc="";MessageBox("QUIT响应错误！"); &#125; &#125; UpdateData(FALSE); closesocket(SockCtrl); WSACleanup(); m_TIPSCTRL.LineScroll(m_TIPSCTRL.GetLineCount());//滚动条置底 GetDlgItem(IDC_PASV)-&gt;EnableWindow(TRUE); GetDlgItem(IDC_PORT)-&gt;EnableWindow(TRUE);&#125; 附上最后的效果图]]></content>
      <categories>
        <category>编程</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>socket</tag>
        <tag>c++</tag>
        <tag>MFC</tag>
        <tag>编程</tag>
        <tag>FTP</tag>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F06%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
